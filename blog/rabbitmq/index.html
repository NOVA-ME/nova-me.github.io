<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>RabbitMQ常见知识点</title><meta content=RabbitMQ常见知识点 name=title><meta content=NOVA-ME name=author><meta content="The road is life." name=description><meta content=website property=og:type><meta content=https://nova-me.github.io/blog/rabbitmq/ property=og:url><meta content=NOVA-ME property=og:site_name><meta content=RabbitMQ常见知识点 property=og:title><meta content="The road is life." property=og:description><meta content=https://nova-me.github.io/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nova-me.github.io/blog/rabbitmq/ property=twitter:url><meta content=RabbitMQ常见知识点 property=twitter:title><meta content="The road is life." property=twitter:description><meta content=https://nova-me.github.io/favicon.ico property=twitter:image><link href=https://nova-me.github.io/blog/rabbitmq/ rel=canonical><link rel="shortcut icon" href=https://nova-me.github.io/favicon.ico type=image/x-icon><link href="https://nova-me.github.io/ atom.xml" rel=alternate title=RSS type=application/atom+xml><link href=https://nova-me.github.io/css/style.css rel=stylesheet><body><div class=wrapper><header><nav class=navBar><a href=/>/home/</a><a href=/about>/about/</a><a href=/blog>/blog/</a><a href=/tags>/tags/</a><div class=themeSwitch><button class="themeButton light" onclick="setTheme('light')" title="Light mode">◐</button><button class="themeButton dark" onclick="setTheme('dark')" title="Dark mode">◑</button></div><script>const setTheme=a=>{document.documentElement.className=a;localStorage.setItem('theme',a)};const getTheme=()=>{const a=localStorage.getItem('theme');a&&setTheme(a)};getTheme()</script></nav><div><a href=..>..</a>/<span class=metaData>rabbitmq</span></div><time datetime=2023-03-03>Published on: <span class=metaData>2023-03-03</span></time><h1>RabbitMQ常见知识点</h1></header><main><h1 id=amqp>AMQP</h1><p>AMQP定义了规范，RabbitMQ是规范实现之一。<h1 id=docker-an-zhuang-rabbitmq>Docker 安装 RabbitMQ</h1><ol><li>下载</ol><pre class=language-shell data-lang=shell style=background:#2e3440;color:#d8dee9><code class=language-shell data-lang=shell><span>docker pull rabbitmq:3.8.2-management
</span></code></pre><ol start=2><li>运行</ol><pre class=language-shell data-lang=shell style=background:#2e3440;color:#d8dee9><code class=language-shell data-lang=shell><span>docker run -d --name rabbitmq3.8.2 -p 5672:5672 -p 15672:15672 -v /Users/felix/share/data:/var/lib/rabbitmq -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=afei123 rabbitmq:3.8.2-management
</span></code></pre><p>说明： -d 后台运行容器； –name 指定容器名； -p 指定服务运行的端口（5672：应用访问端口；15672：控制台Web端口号）； -v 映射目录； -e 指定环境变量；（RABBITMQ_DEFAULT_VHOST：默认虚拟机名；RABBITMQ_DEFAULT_USER：默认的用户名；RABBITMQ_DEFAULT_PASS：默认用户名的密码）<ol start=3><li>查看在容器中查看运行中的RabbitMQ</ol><p>docker exec -it 645e674c1151 rabbitmqctl list_exchanges<h1 id=consumer>Consumer</h1><p>多个消费者消费消息时，默认Round-robin轮询分发，若有的消费者处理得快，想让能者多得，多劳多得，则可以配置消费者 quality of service。<pre style=background:#2e3440;color:#d8dee9><code><span>void basicQos(int prefetchCount);
</span></code></pre><h2 id=xiao-fei-zhe-ackji-zhi>消费者ack机制</h2><p>保证消息一定被消费<h1 id=exchanger-type>Exchanger Type</h1><h2 id=fanout>fanout</h2><p>所有绑定的队列都收到消息<p><img alt=img src=/rabbitmq/python-three-overall.png><h2 id=direct>direct</h2><p>消息由指定的的 routing key 路由，是特殊的fanout。subscribe only to a subset of the messages<p><img alt=img src=/rabbitmq/python-four.png><h2 id=topic>topic</h2><p>消息由指定的routing key路由，可以支持通配符。<p><img alt=img src=/rabbitmq/python-five.png><h1 id=producer>Producer</h1><h2 id=reliable-publishing>Reliable publishing</h2><p>Use publisher confirms to make sure published messages have safely reached the broker.<ol><li>同步 confirms</ol><pre class=language-shell data-lang=shell style=background:#2e3440;color:#d8dee9><code class=language-shell data-lang=shell><span>waitForConfirmsOrDie();
</span></code></pre><ol start=2><li>异步confirms</ol><p>异步确认有一个序列号，用于异步绑定消息，参考：<code>com.rabbitmq.client.Channel#getNextPublishSeqNo</code><p>。异步处理的时候添加一个异步回掉接口：<pre class=language-java data-lang=java style=background:#2e3440;color:#d8dee9><code class=language-java data-lang=java><span style=color:#8fbcbb>com</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>rabbitmq</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>client</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>Channel</span><span>#</span><span style=color:#88c0d0>addConfirmListener</span><span>(</span><span style=color:#8fbcbb>com</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>rabbitmq</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>client</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>ConfirmCallback</span><span style=color:#eceff4>, </span><span style=color:#8fbcbb>com</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>rabbitmq</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>client</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>ConfirmCallback</span><span>)
</span></code></pre><h2 id=shi-wu>事务</h2><p>事务可参考：<pre class=language-java data-lang=java style=background:#2e3440;color:#d8dee9><code class=language-java data-lang=java><span style=color:#8fbcbb>com</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>rabbitmq</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>client</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>Channel</span><span>#</span><span style=color:#88c0d0>txCommit</span><span>()</span><span style=color:#eceff4>;
</span><span style=color:#8fbcbb>com</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>rabbitmq</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>client</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>Channel</span><span>#</span><span style=color:#88c0d0>txRollback</span><span>()</span><span style=color:#eceff4>;
</span></code></pre><h1 id=ying-yong>应用</h1><h2 id=cai-yong-rabbitmqgao-ding-chao-shi-ding-dan>采用RabbitMQ搞定超时订单</h2><p>使用RabbitMQ来实现延迟任务必须先了解RabbitMQ的两个概念：消息的TTL和死信Exchange，通过这两者的组合来实现上述需求。<ul><li><strong>消息的TTL（Time To Live）</strong></ul><p>消息的<code>TTL</code>就是消息的存活时间。RabbitMQ 可以对队列和消息分别设置<code>TTL</code>。对队列设置就是队列没有消费者连着的保留时间，也可以对每一个单独的消息做单独的设置。超过了这个时间，我们认为这个消息就死了，称之为死信。<p>那么，如何设置这个TTL值呢？有两种方式，第一种是在创建队列的时候设置队列的<code>"x-message-ttl"</code>属性，如下：<pre class=language-java data-lang=java style=background:#2e3440;color:#d8dee9><code class=language-java data-lang=java><span style=color:#8fbcbb>Map</span><span><</span><span style=color:#8fbcbb>String</span><span style=color:#eceff4>, </span><span style=color:#8fbcbb>Object</span><span>> args </span><span style=color:#81a1c1>= new </span><span style=color:#8fbcbb>HashMap</span><span><</span><span style=color:#8fbcbb>String</span><span style=color:#eceff4>, </span><span style=color:#8fbcbb>Object</span><span>>()</span><span style=color:#eceff4>;
</span><span>args</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>put</span><span>(</span><span style=color:#a3be8c>"x-message-ttl"</span><span style=color:#eceff4>, </span><span style=color:#b48ead>6000</span><span>)</span><span style=color:#eceff4>;
</span><span>channel</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>queueDeclare</span><span>(queueName</span><span style=color:#eceff4>,</span><span> durable</span><span style=color:#eceff4>,</span><span> exclusive</span><span style=color:#eceff4>,</span><span> autoDelete</span><span style=color:#eceff4>,</span><span> args)</span><span style=color:#eceff4>;
</span></code></pre><p>这样所有被投递到该队列的消息都最多不会存活超过6s。<p>另一种方式便是针对每条消息设置TTL，代码如下：<pre class=language-java data-lang=java style=background:#2e3440;color:#d8dee9><code class=language-java data-lang=java><span>AMQP</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>BasicProperties</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>Builder</span><span> builder </span><span style=color:#81a1c1>= new </span><span style=color:#8fbcbb>AMQP</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>BasicProperties</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>Builder</span><span>()</span><span style=color:#eceff4>;
</span><span>builder</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>expiration</span><span>(</span><span style=color:#a3be8c>"6000"</span><span>)</span><span style=color:#eceff4>;
</span><span>AMQP</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>BasicProperties</span><span> properties </span><span style=color:#81a1c1>=</span><span> builder</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>build</span><span>()</span><span style=color:#eceff4>;
</span><span>channel</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>basicPublish</span><span>(exchangeName</span><span style=color:#eceff4>,</span><span> routingKey</span><span style=color:#eceff4>,</span><span> mandatory</span><span style=color:#eceff4>,</span><span> properties</span><span style=color:#eceff4>, </span><span style=color:#a3be8c>"msg body"</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>getBytes</span><span>())</span><span style=color:#eceff4>;
</span></code></pre><p>这样这条消息的过期时间也被设置成了6s。<blockquote><p>但这两种方式是有区别的，如果设置了队列的TTL属性，那么一旦消息过期，就会被队列丢弃，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间。 另外，还需要注意的一点是，如果不设置TTL，表示消息永远不会过期，如果将TTL设置为0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</blockquote><p>单靠死信还不能实现延迟任务，还要靠<code>Dead Letter Exchange</code>。<ul><li><strong>Dead Letter Exchanges</strong></ul><p>一个消息在满足如下条件下，会进死信路由，记住这里是路由而不是队列，一个路由可以对应很多队列。<ol><li>一个消息被<code>Consumer</code>拒收了，并且<code>reject</code>方法的参数里<code>requeue</code>是<code>false</code>。也就是说不会被再次放在队列里，被其他消费者使用。<li>上面的消息的<code>TTL</code>到了，消息就过期了。<li>队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上。</ol><p><code>Dead Letter Exchange</code>其实就是一种普通的<code>exchange</code>，和创建其他<code>exchange</code>没有两样。只是在某一个设置<code>Dead Letter Exchange</code>的队列中有消息过期了，会自动触发消息的转发，发送到<code>Dead Letter Exchange</code>中去。</main><footer><p class=tagsData><a href=/tags/java>#Java</a><hr><div class=footContainer><div class=footLeft>Built with <a rel="noopener noreferrer" href=https://github.com/getzola/zola target=_blank>Zola</a></div><div class=footRight><img class="footGif noStyle" alt=footGif loading=lazy src=https://i.ibb.co/XYDpfcs/foot.gif><a href="https://nova-me.github.io/ atom.xml" rel="noopener noreferrer" title="Subscribe via RSS for updates." class=metaData target=_blank>RSS</a></div></div></footer></div>