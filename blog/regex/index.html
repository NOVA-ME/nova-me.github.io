<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>正则表达式</title><meta content=正则表达式 name=title><meta content=NOVA-ME name=author><meta content="The road is life." name=description><meta content=website property=og:type><meta content=https://nova-me.github.io/blog/regex/ property=og:url><meta content=NOVA-ME property=og:site_name><meta content=正则表达式 property=og:title><meta content="The road is life." property=og:description><meta content=https://nova-me.github.io/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://nova-me.github.io/blog/regex/ property=twitter:url><meta content=正则表达式 property=twitter:title><meta content="The road is life." property=twitter:description><meta content=https://nova-me.github.io/favicon.ico property=twitter:image><link href=https://nova-me.github.io/blog/regex/ rel=canonical><link rel="shortcut icon" href=https://nova-me.github.io/favicon.ico type=image/x-icon><link href="https://nova-me.github.io/ atom.xml" rel=alternate title=RSS type=application/atom+xml><link href=https://nova-me.github.io/css/style.css rel=stylesheet><body><div class=wrapper><header><nav class=navBar><a href=/>/home/</a><a href=/about>/about/</a><a href=/blog>/blog/</a><a href=/tags>/tags/</a><div class=themeSwitch><button class="themeButton light" onclick="setTheme('light')" title="Light mode">◐</button><button class="themeButton dark" onclick="setTheme('dark')" title="Dark mode">◑</button></div><script>const setTheme=a=>{document.documentElement.className=a;localStorage.setItem('theme',a)};const getTheme=()=>{const a=localStorage.getItem('theme');a&&setTheme(a)};getTheme()</script></nav><div><a href=..>..</a>/<span class=metaData>regex</span></div><time datetime=2023-03-16>Published on: <span class=metaData>2023-03-16</span></time><h1>正则表达式</h1></header><main><p>这篇文章是对正则表达式的一个总结</p><span id=continue-reading></span><h2 id=javazheng-ze-shi-li>Java正则示例</h2><pre class=language-java data-lang=java style=background:#2e3440;color:#d8dee9><code class=language-java data-lang=java><span style=color:#81a1c1>import </span><span style=color:#8fbcbb>java</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>util</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>regex</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>Matcher</span><span style=color:#eceff4>;
</span><span style=color:#81a1c1>import </span><span style=color:#8fbcbb>java</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>util</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>regex</span><span style=color:#eceff4>.</span><span style=color:#8fbcbb>Pattern</span><span style=color:#eceff4>;
</span><span>
</span><span>    </span><span style=color:#d08770>@Test
</span><span>    </span><span style=color:#81a1c1>public</span><span> void </span><span style=color:#88c0d0>RegexMatches</span><span>() {
</span><span>        </span><span style=color:#8fbcbb>String</span><span> line </span><span style=color:#81a1c1>= </span><span style=color:#a3be8c>"a12bc"</span><span style=color:#eceff4>;
</span><span>        </span><span style=color:#8fbcbb>String</span><span> patternStr </span><span style=color:#81a1c1>= </span><span style=color:#a3be8c>"^.*?(</span><span style=color:#ebcb8b>\\</span><span style=color:#a3be8c>d+).*?$"</span><span style=color:#eceff4>;
</span><span>        </span><span style=color:#8fbcbb>Pattern</span><span> compile </span><span style=color:#81a1c1>= </span><span style=color:#8fbcbb>Pattern</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>compile</span><span>(patternStr)</span><span style=color:#eceff4>;
</span><span>        </span><span style=color:#8fbcbb>Matcher</span><span> matcher </span><span style=color:#81a1c1>=</span><span> compile</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>matcher</span><span>(line)</span><span style=color:#eceff4>;
</span><span>        </span><span style=color:#81a1c1>if </span><span>(matcher</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>find</span><span>()) {
</span><span>            </span><span style=color:#8fbcbb>System</span><span style=color:#eceff4>.</span><span>out</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>println</span><span>(</span><span style=color:#a3be8c>"Number is: " </span><span style=color:#81a1c1>+</span><span> matcher</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>group</span><span>(</span><span style=color:#b48ead>1</span><span>))</span><span style=color:#eceff4>;
</span><span>        } </span><span style=color:#81a1c1>else </span><span>{
</span><span>            </span><span style=color:#8fbcbb>System</span><span style=color:#eceff4>.</span><span>out</span><span style=color:#eceff4>.</span><span style=color:#88c0d0>println</span><span>(</span><span style=color:#a3be8c>"No numbers."</span><span>)</span><span style=color:#eceff4>;
</span><span>        }
</span><span>    }
</span></code></pre><h3 id=bu-huo-zu>捕获组</h3><p>捕获组是将多个字符视为一个单元的一种方法。 它们是通过将要分组的字符放在一组括号中来创建的。 例如，正则表达式(dog)创建包含字母d，o和g的单个组。 捕获组通过从左到右计算它们的左括号来编号。 在表达式((A)(B(C)))中，例如，有四个这样的组<ul><li>((A)(B(C)))<li>(A)<li>(B(C))<li>(C) 要查找表达式中存在多少个组，请在<code>Matcher</code>对象上调用<code>groupCount()</code>方法。 <code>groupCount()</code>方法返回一个<code>int</code>类型值，显示<code>Matcher</code>模式中存在的捕获组数。 还有一个特殊组，即组0，它始终代表整个表达式。 该组未包含在<code>groupCount()</code>报告的总数中。</ul><h3 id=chang-yong-zheng-ze>常用正则</h3><table><thead><tr><th>子表达式<th>匹配<tbody><tr><td>\<td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，‘n’ 匹配字符 “n”。‘\n’ 匹配一个换行符。序列 ‘\’ 匹配 “" 而 “(” 则匹配 “(”<tr><td>^<td>匹配行的开头<tr><td>$<td>匹配除换行符之外的任何单个字符，使用m选项也可以匹配换行符<tr><td>*<td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}<tr><td>+<td>匹配前面的子表达式一次或多次。例如，‘zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}<tr><td>?<td>匹配前面的子表达式零次或一次。例如，“do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}<tr><td>{n}<td>n 是一个非负整数。匹配确定的 n 次。例如，‘o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o<tr><td>{n,}<td>n 是一个非负整数。至少匹配n 次。例如，‘o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。‘o{1,}’ 等价于 ‘o+’。‘o{0,}’ 则等价于 ‘o*’<tr><td>{n,m}<td>m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，“o{1,3}” 将匹配 “fooooood” 中的前三个 o。‘o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格<tr><td>?<td>当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，‘o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’<tr><td>.<td>匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像“(.<tr><td>(pattern)<td>匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(’ 或 ‘)’<tr><td>(?:pattern)<td>匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (<tr><td>(?=pattern)<td>正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95<tr><td>(?!pattern)<td>正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95<tr><td>(?<=pattern)<td>反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?<=95<tr><td>(?&LT!pattern)<td>反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&LT!95<tr><td>x<td>y<tr><td>[xyz]<td>字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’<tr><td><sup class=footnote-reference><a href=#xyz>1</a></sup><td>负值字符集合。匹配未包含的任意字符。例如， ‘<sup class=footnote-reference><a href=#abc>2</a></sup>’ 可以匹配 “plain” 中的’p’、‘l’、‘i’、‘n’<tr><td>[a-z]<td>字符范围。匹配指定范围内的任意字符。例如，‘[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符<tr><td><sup class=footnote-reference><a href=#a-z>3</a></sup><td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，‘<sup class=footnote-reference><a href=#a-z>3</a></sup>’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符<tr><td>\b<td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配“never“ 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’<tr><td>\B<td>匹配非单词边界。‘er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’<tr><td>\cx<td>匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符<tr><td>\d<td>匹配一个数字字符。等价于 [0-9]<tr><td>\D<td>匹配一个非数字字符。等价于 <sup class=footnote-reference><a href=#0-9>4</a></sup><tr><td>\f<td>匹配一个换页符。等价于 \x0c 和 \cL<tr><td>\n<td>匹配一个换行符。等价于 \x0a 和 \cJ<tr><td>\r<td>匹配一个回车符。等价于 \x0d 和 \cM<tr><td>\s<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]<tr><td>\S<td>匹配任何非空白字符。等价于 <sup class=footnote-reference><a href="# \f\n\r\t\v">5</a></sup><tr><td>\t<td>匹配一个制表符。等价于 \x09 和 \cI<tr><td>\v<td>匹配一个垂直制表符。等价于 \x0b 和 \cK<tr><td>\w<td>匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’<tr><td>\W<td>匹配非字母、数字、下划线。等价于 ‘<sup class=footnote-reference><a href=#A-Za-z0-9_>6</a></sup>’<tr><td>\xn<td>匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，‘\x41’ 匹配 “A”。‘\x041’ 则等价于 ‘\x04’ & “1”。正则表达式中可以使用 ASCII 编码<tr><td>\num<td>匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，‘(.)\1’ 匹配两个连续的相同字符<tr><td>\n<td>标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值<tr><td>\nm<td>标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm<tr><td>\nml<td>如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml<tr><td>\un<td>匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)</table></main><footer><p class=tagsData><a href=/tags/java>#Java</a><hr><div class=footContainer><div class=footLeft>Built with <a rel="noopener noreferrer" href=https://github.com/getzola/zola target=_blank>Zola</a></div><div class=footRight><img class="footGif noStyle" alt=footGif loading=lazy src=https://i.ibb.co/XYDpfcs/foot.gif><a href="https://nova-me.github.io/ atom.xml" rel="noopener noreferrer" title="Subscribe via RSS for updates." class=metaData target=_blank>RSS</a></div></div></footer></div>