<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://nova-me.github.io</id>
    <title>林间小筑</title>
    <updated>2021-08-01T09:59:24.822Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://nova-me.github.io"/>
    <link rel="self" href="https://nova-me.github.io/atom.xml"/>
    <subtitle>The road is life.</subtitle>
    <logo>https://nova-me.github.io/images/avatar.png</logo>
    <icon>https://nova-me.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 林间小筑</rights>
    <entry>
        <title type="html"><![CDATA[Java并发总结]]></title>
        <id>https://nova-me.github.io/post/java-bing-fa-zong-jie/</id>
        <link href="https://nova-me.github.io/post/java-bing-fa-zong-jie/">
        </link>
        <updated>2019-03-21T08:12:35.000Z</updated>
        <summary type="html"><![CDATA[<p>本文只是对Java并发知识的一个总结, Java并发是一个很难的问题，不是一篇博文能够说清，以后还需在实践中多多积累学习才是。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本文只是对Java并发知识的一个总结, Java并发是一个很难的问题，不是一篇博文能够说清，以后还需在实践中多多积累学习才是。</p>
<!-- more -->
<h2 id="多线程的概念">多线程的概念</h2>
<p>多线程程序在较低的层次上扩展了多任务的概念：一个程序同时执行多个任务。通常，<br>
每一个任务称为一个线程（ thread), 它是线程控制的简称。可以同时运行一个以上线程的程<br>
序称为多线程程序（multithreaded)。<br>
那么，多进程与多线程有哪些区别呢？ 本质的区别在于每个进程拥有自己的一整套变<br>
量， 而线程则共享数据。 这听起来似乎有些风险， 的确也是这样， 在本章稍后将可以看到这<br>
个问题。然而，共享变量使线程之间的通信比进程之间的通信更有效、 更容易。 此外， 在有<br>
些操作系统中，与进程相比较， 线程更“ 轻量级”， 创建、 撤销一个线程比启动新进程的开<br>
销要小得多。</p>
<h2 id="线程状态">线程状态</h2>
<p>Java线程包含如下状态：</p>
<ul>
<li>new(新创建)</li>
<li>Runnable(可运行)</li>
<li>Blocked(被阻塞)</li>
<li>Waiting(等待)</li>
<li>Timed waiting(计时等待)</li>
<li>Terminated(被终止)</li>
</ul>
<blockquote>
<p>Java获取线程状态的API，getState方法.<br>
状态转换如图所示<br>
<img src="https://nova-me.github.io/post-images/1627808308619.jpg" alt="" loading="lazy"></p>
</blockquote>
<h2 id="线程属性">线程属性</h2>
<p>Java线程包含如下属性：</p>
<ul>
<li>Priority(优先级)</li>
<li>Daemon thread(守护线程)</li>
<li>未捕获异常处理</li>
</ul>
<h3 id="优先级">优先级</h3>
<pre><code class="language-java">/**
 * The minimum priority that a thread can have.
 */
public final static int MIN_PRIORITY = 1;

/**
 * The default priority that is assigned to a thread.
 */
public final static int NORM_PRIORITY = 5;

/**
 * The maximum priority that a thread can have.
 */
public final static int MAX_PRIORITY = 10;

public final void setPriority(int newPriority) {
    ThreadGroup g;
    checkAccess();
    if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) {
        throw new IllegalArgumentException();
    }
    if ((g = getThreadGroup()) != null) {
        if (newPriority &gt; g.getMaxPriority()) {
            newPriority = g.getMaxPriority();
        }
        setPriority0(priority = newPriority);
    }
}
</code></pre>
<p>Java线程优先级默认值为5，取值区间为1-10的一个整数</p>
<h3 id="守护线程">守护线程</h3>
<pre><code class="language-java">public final void setDaemon(boolean on) {
    checkAccess();
    if (isAlive()) {
        throw new IllegalThreadStateException();
    }
    daemon = on;
}
</code></pre>
<p>设置一个线程为守护线程。守护线程一般为其它线程提供服务</p>
<h2 id="同步锁">同步，锁</h2>
<blockquote>
<p>线程之间是有共享内存的，为了防止运行时出现数据竞争，Java提供了一系列的工具来解决这个问题</p>
</blockquote>
<h3 id="synchronized关键字">synchronized关键字</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[序]]></title>
        <id>https://nova-me.github.io/post/xu/</id>
        <link href="https://nova-me.github.io/post/xu/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>很早之前就一直想写博客，总是因为不够自律而不断耽搁，之前也学习过很多东西并未总结，过段时间，自然就淡了，希望从这里开始自己的博客之旅吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>很早之前就一直想写博客，总是因为不够自律而不断耽搁，之前也学习过很多东西并未总结，过段时间，自然就淡了，希望从这里开始自己的博客之旅吧。</p>
<!-- more -->
<p>加油，不算年轻的年轻人！😄</p>
]]></content>
    </entry>
</feed>